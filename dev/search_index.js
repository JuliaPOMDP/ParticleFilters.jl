var documenterSearchIndex = {"docs":
[{"location":"depletion/#Handling-Particle-Depletion","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"","category":"section"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"Many of the most common problems with particle filters are related to particle depletion, that is, a lack of particles corresponding to the true state. In many cases, it is not difficult to overcome these problems, but domain-specific heuristics are often more effective than generic approaches.","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"The recommended way to handle particle depletion in a BootstrapFilter or BasicParticleFilter is to add a postprocessing step. In the BasicParticleFilter, this is a required argument; in the BootstrapFilter, it is an optional keyword argument.","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"A postprocessing function takes 6 arguments:","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"postprocess(bp, a, o, b, bb, rng)","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"bp is the new belief, a is the action, o is the observation, b is the old belief, bb is the belief after preprocessing, and rng is the random number generator. See the Basic Particle Filter section to see where postprocess is called in the code. The postprocessing function should return the modified belief. This can be the same object bp modified in place or a new object.","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"tip: Tip\nIf you don't need all of the arguments, you can use the splat operator ... to ignore them, e.g. postprocess(bp, a, o, args...).","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"tip: Tip\nThe function does not need to be named postprocess. It can have any name or be anonymous.","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"Creating a postprocessing function is best illustrated by a simple example:","category":"page"},{"location":"depletion/#Example","page":"Handling Particle Depletion","title":"Example","text":"","category":"section"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"In this example, we have a system with integer states states and actions, deterministic dynamics, and an observation that is uniformly distributed over the current state plus or minus 1. If all state particles start 1, action 1 is taken, and observation 4 is received, then no particles are consistent with the observation. This will yield a warning about particle depletion and produce a belief with zero-weighted particles that cannot be sampled from or used effectively: ","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"using ParticleFilters, Distributions\n\ndynamics(s, a, rng) = s + a\nlikelihood(s_previous, a, s, o) = abs(o - s) <= 1\nnaive_pf = BootstrapFilter(dynamics, likelihood, 3)\n\nb0 = ParticleCollection([1, 1, 1])\na = 1\no = 4\n\nbp = update(naive_pf, b0, a, o)\nnothing # hide","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"To fix this, we define a postprocessing step to refill the particle belief with particles consistent with the observation:","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"function refill_with_consistent(bp, a, o, b, bb, rng)\n    if weight_sum(bp) == 0.0\n        return WeightedParticleBelief([o-1, o, o+1], ones(3))\n    else\n        return bp\n    end\nend\nnothing # hide","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"Note that this solution is very domain-specific. It relies on specific knowledge about the observation function. In other applications, you will likely need to be clever about coming up with ways to create replacement particles in cases of depletion. Armed with the new postprocessing step, we can create a new filter and use it for a belief update:","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"pf = BootstrapFilter(dynamics, likelihood, 3; postprocess=refill_with_consistent)\nbp = update(pf, b0, a, o)","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"While this new belief is consistent with the observation, it does not take into account the dynamics or information from the previous steps. A better solution might be to populate the new belief with particles as near as possible to the previous particles while still being consistent with the observation. Tricks like this are often necessary to get good performance in practice and they are an important part of the art of particle filtering.","category":"page"},{"location":"depletion/#Additional-Examples-of-Postprocessing-Functions","page":"Handling Particle Depletion","title":"Additional Examples of Postprocessing Functions","text":"","category":"section"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"The following section provides additional examples of strategies that commonly work well and additional postprocessing functions.","category":"page"},{"location":"depletion/#Replacing-Zero-Weight-Particles","page":"Handling Particle Depletion","title":"Replacing Zero-Weight Particles","text":"","category":"section"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"Rather than waiting until all particle weights are zero, it is often effective to replace zero-weight particles as soon as they are detected. If a function consistent_state(o, rng) is written to generate states consistent with the observation, this replacement can be accomplished with the following postprocessing function:","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"function replace_zero_weight_particles(bp, a, o, b, bb, rng)\n\n    n = n_particles(bp)\n    new_weight = weight_sum(bp)/n\n\n    for i in 1:n\n        if weight(bp, i) == 0.0\n            s = consistent_state(o, rng)\n            set_pair!(bp, i, s => new_weight)\n        end\n    end\n\n    return bp\nend","category":"page"},{"location":"depletion/#Adding-Artificial-Noise","page":"Handling Particle Depletion","title":"Adding Artificial Noise","text":"","category":"section"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"In continuous-state systems with deterministic dynamics, it can be useful to add artificial noise to the states as follows:","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"function add_noise(bp, a, o, b, bb, rng)\n    for i in 1:n_particles(bp)\n        p = particle(bp, i)\n        set_particle!(bp, i, p + 0.1*randn(rng))\n    end\n    return bp\nend","category":"page"},{"location":"depletion/#Combining-Multiple-Postprocessing-Steps","page":"Handling Particle Depletion","title":"Combining Multiple Postprocessing Steps","text":"","category":"section"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"It is often useful to combine multiple postprocessing steps. This can be accomplished convenienttly with the PostprocessChain function:","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"PostprocessChain(replace_zero_weight_particles, add_noise)","category":"page"},{"location":"depletion/#Replacing-Zero-Weight-Particles-with-States-from-the-Initial-Distribution","page":"Handling Particle Depletion","title":"Replacing Zero-Weight Particles with States from the Initial Distribution","text":"","category":"section"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"If no other information is available, a quick solution is to replace zero-weight particles with states drawn from the initial distribution. In POMDPs.jl, the initialstate function can be used to generate these states. This implementation uses a callable object to store the POMDP model.","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"using ParticleFilters, POMDPs, POMDPModels\n\nstruct ReplaceWithInitial{M <: POMDP} <: Function\n    m::M\n    threshold::Float64 # replace particles with normalized weights below this\nend\n\nfunction (r::ReplaceWithInitial)(bp, a, o, b, bb, rng)\n    ws = weights(bp)\n    wsum = weight_sum(bp)\n    nws = ws ./ wsum\n    n = n_particles(bp)\n    for i in 1:n\n        if nws[i] < r.threshold\n            set_pair!(bp, i, rand(rng, initial_state(r.m)) => wsum/n)\n        end\n    end\n    return bp\nend\n\nnothing # hide","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"The filter can then be created as follows:","category":"page"},{"location":"depletion/","page":"Handling Particle Depletion","title":"Handling Particle Depletion","text":"m = TigerPOMDP()\npf = BootstrapFilter(m, 1, postprocess=ReplaceWithInitial(m, 0.1))","category":"page"},{"location":"beliefs/#Beliefs","page":"Beliefs","title":"Beliefs","text":"","category":"section"},{"location":"beliefs/#Types","page":"Beliefs","title":"Types","text":"","category":"section"},{"location":"beliefs/","page":"Beliefs","title":"Beliefs","text":"ParticleFilters.jl provides two types of particle beliefs. ParticleCollection is little more than a vector of unweighted particles. WeightedParticleBelief allows for different weights for each of the particles.","category":"page"},{"location":"beliefs/","page":"Beliefs","title":"Beliefs","text":"Both are subtypes of AbstractParticleBelief and implement the same particle belief interface. For probability mass calculations (the pdf function), a dictionary containing the normalized sum of weights for all identical particles is created on the first call and cached for efficient future querying.","category":"page"},{"location":"beliefs/","page":"Beliefs","title":"Beliefs","text":"warning: Warning\nYou should not access the fields of ParticleCollection or WeightedParticleBelief directly. Use the provided interface instead to ensure that internal data structures are maintained correctly.","category":"page"},{"location":"beliefs/#ParticleFilters.ParticleCollection","page":"Beliefs","title":"ParticleFilters.ParticleCollection","text":"ParticleCollection{S}\n\nUnweighted particle belief consisting of equally important particles of type S.\n\n\n\n\n\n","category":"type"},{"location":"beliefs/#ParticleFilters.WeightedParticleBelief","page":"Beliefs","title":"ParticleFilters.WeightedParticleBelief","text":"WeightedParticleBelief{S}\n\nWeighted particle belief consisting of particles of type S and their associated weights.\n\nAn alias table is used for efficient sampling.\n\n\n\n\n\n","category":"type"},{"location":"beliefs/#Interface","page":"Beliefs","title":"Interface","text":"","category":"section"},{"location":"beliefs/#Standard-POMDPs.jl-Distribution-Interface","page":"Beliefs","title":"Standard POMDPs.jl Distribution Interface","text":"","category":"section"},{"location":"beliefs/","page":"Beliefs","title":"Beliefs","text":"The following functions from the POMDPs.jl distributions interface (a subset of the Distributions.jl interface) provide basic ways of interacting with particle beliefs as distributions (click on each for documentation):","category":"page"},{"location":"beliefs/","page":"Beliefs","title":"Beliefs","text":"rand\npdf\nsupport\nmode\nmean","category":"page"},{"location":"beliefs/#Particle-Interface","page":"Beliefs","title":"Particle Interface","text":"","category":"section"},{"location":"beliefs/","page":"Beliefs","title":"Beliefs","text":"These functions provide read only access to the particles, weights, and other aspects of the beliefs (click on each for docstrings):","category":"page"},{"location":"beliefs/","page":"Beliefs","title":"Beliefs","text":"n_particles\nparticles\nweights\nweighted_particles\nweight_sum\nweight\nparticle\nParticleFilters.probdict\neffective_sample_size","category":"page"},{"location":"beliefs/","page":"Beliefs","title":"Beliefs","text":"To change the particles or weights in a belief, the following functions are provided:","category":"page"},{"location":"beliefs/","page":"Beliefs","title":"Beliefs","text":"set_particle!\nset_weight!\nset_pair!\npush_pair!","category":"page"},{"location":"beliefs/#Interface-Docstrings","page":"Beliefs","title":"Interface Docstrings","text":"","category":"section"},{"location":"beliefs/#Base.rand","page":"Beliefs","title":"Base.rand","text":"rand(rng::AbstractRNG, d::Any)\n\nReturn a random element from distribution or space d.\n\nIf d is a state or transition distribution, the sample will be a state; if d is an action distribution, the sample will be an action or if d is an observation distribution, the sample will be an observation.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#Distributions.pdf","page":"Beliefs","title":"Distributions.pdf","text":"pdf(d::Any, x::Any)\n\nEvaluate the probability density of distribution d at sample x.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#Distributions.support","page":"Beliefs","title":"Distributions.support","text":"support(d::Any)\n\nReturn an iterable object containing the possible values that can be sampled from distribution d. Values with zero probability may be skipped.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#StatsBase.mode","page":"Beliefs","title":"StatsBase.mode","text":"mode(d::Any)\n\nReturn the most likely value in a distribution d.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#Statistics.mean","page":"Beliefs","title":"Statistics.mean","text":"mean(d::Any)\n\nReturn the mean of a distribution d.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.n_particles","page":"Beliefs","title":"ParticleFilters.n_particles","text":"n_particles(b::AbstractParticleBelief)\n\nReturn the number of particles.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.particles","page":"Beliefs","title":"ParticleFilters.particles","text":"particles(b::AbstractParticleBelief)\n\nReturn an iterator over the particles.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.weights","page":"Beliefs","title":"ParticleFilters.weights","text":"weights(b::AbstractParticleBelief)\n\nReturn an iterator over the weights.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.weighted_particles","page":"Beliefs","title":"ParticleFilters.weighted_particles","text":"weighted_particles(b::AbstractParticleBelief)\n\nReturn an iterator over particle-weight pairs.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.weight_sum","page":"Beliefs","title":"ParticleFilters.weight_sum","text":"weight_sum(b::AbstractParticleBelief)\n\nReturn the sum of the weights of the particle collection.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.weight","page":"Beliefs","title":"ParticleFilters.weight","text":"weight(b::AbstractParticleBelief, i)\n\nReturn the weight for particle i.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.particle","page":"Beliefs","title":"ParticleFilters.particle","text":"particle(b::AbstractParticleBelief, i)\n\nReturn particle i.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.probdict","page":"Beliefs","title":"ParticleFilters.probdict","text":"probdict(b::AbstractParticleBelief)\n\nReturn a dictionary mapping states to probabilities.\n\nThe probability is the normalized sum of the weights for all matching particles.\n\nFor ParticleCollection and WeightedParticleBelief, the result is cached for efficiency so the calculation is only performed the first time this is called. There is a default implementation for all AbstractParticleBeliefs, but it is inefficient (it creates a new dictionary every time). New AbstractParticleBelief implementations should provide an efficient implementation.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.effective_sample_size","page":"Beliefs","title":"ParticleFilters.effective_sample_size","text":"effective_sample_size(b::AbstractParticleBelief)\n\nCalculate the effective sample size of a particle belief.\n\nThe effective sample size is 1sum_i hatw_i^2 where hatw_i = w_i  sum_i w_i.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.set_particle!","page":"Beliefs","title":"ParticleFilters.set_particle!","text":"set_particle!(b::AbstractParticleBelief, i, s)\n\nChange the particle at index i without changing the weight.\n\nThis may not work for beliefs with immutable particle storage.\n\nExample\n\nset_particle!(b, 3, s)\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.set_weight!","page":"Beliefs","title":"ParticleFilters.set_weight!","text":"set_weight!(b::AbstractParticleBelief, i, w)\n\nChange the weight at index i without changing the particle.\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.set_pair!","page":"Beliefs","title":"ParticleFilters.set_pair!","text":"set_pair!(b::AbstractParticleBelief{S}, i, sw::Pair{S,Float64})\n\nChange both the particle and weight at index i. This will also adjust the weight sum and probabilities appropriately.\n\nExample\n\nset_pair!(b, 3, s=>0.5)\n\n\n\n\n\n","category":"function"},{"location":"beliefs/#ParticleFilters.push_pair!","page":"Beliefs","title":"ParticleFilters.push_pair!","text":"push_pair!(b::AbstractParticleBelief{S}, sw::Pair{S,Float64})\n\nPush a new particle and weight pair onto the end of the belief. This will also adjust the weight sum and probabilities appropriately.\n\nExample\n\npush_pair!(b, s=>0.5)\n\n\n\n\n\n","category":"function"},{"location":"basic/#Basic-Particle-Filter","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"","category":"section"},{"location":"basic/","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"The BasicParticleFilter type is a flexible structure for building a particle filter. It simply contains functions that carry out each of the steps of a particle filter belief update.","category":"page"},{"location":"basic/","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"The basic particle filtering step in ParticleFilters.jl is implemented in the update function, and consists of four steps:","category":"page"},{"location":"basic/","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"Preprocessing - before the prediction step, it may be useful to preprocess the belief, for example resampling if there are not enough distinct particles\nPrediction (or propagation) - each state particle is simulated forward one step in time\nReweighting - an explicit measurement (observation) model is used to calculate a new weight\nPostprocessing - after the reweighting step, it may be useful to postprocess the belief, for example detecting particle degeneracy and sampling new particles that are consistent with the observation","category":"page"},{"location":"basic/","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"In code, the update is written:","category":"page"},{"location":"basic/","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"function update(up::BasicParticleFilter, b::AbstractParticleBelief, a, o)\n    bb = up.preprocess(b, a, o, up.rng)\n    particles = up.predict(bb, a, o, up.rng)\n    weights = up.reweight(bb, a, particles, o)\n    bp = WeightedParticleBelief(particles, weights)\n    return up.postprocess(bp, a, o, b, bb, up.rng)\nend","category":"page"},{"location":"basic/","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"note: Note\nIn the future, the steps in an update may change (for instance, the prediction and reweighting steps may be combined into a single function). However, we will maintain compatibility constructors so that code written for this 4-step process will continue to work.","category":"page"},{"location":"basic/","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"A BasicParticleFilter is constructed by passing functions that implement each of the four steps. For example, a simple filter that adds Gaussian noise to each particle and reweights based on a Gaussian observation model is implemented in the following block. Note that there are no pre- or post-processing steps in this example.","category":"page"},{"location":"basic/","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"using ParticleFilters, Distributions\n\npreprocess(b, args...) = b\npredict(b, a, o, rng) = particles(b) .+ a .+ randn(rng, n_particles(b))\nreweight(b, a, particles, o) = weights(b) .* [pdf(Normal(p, 1.0), o) for p in particles]\npostprocess(bp, args...) = bp\n\npf = BasicParticleFilter(preprocess, predict, reweight, postprocess)","category":"page"},{"location":"basic/","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"This filter can be used for an update as follows:","category":"page"},{"location":"basic/","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"\nb = ParticleCollection([1.0, 2.0, 3.0])\na = 1.0\no = 2.0\n\nbp = update(pf, b, a, o)","category":"page"},{"location":"basic/","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"In order to give access to additional information such as static dynamics parameters, consider using a callable object. For additional examples, and to re-use elements from the BootstrapFilter, see the BootstrapFilter source code.","category":"page"},{"location":"basic/","page":"Basic Particle Filter","title":"Basic Particle Filter","text":"Some building blocks for constructing a BasicParticleFilter are provided in the ParticleFilters module. For example, the BasicPredictor, BasicReweighter, POMDPPredictor, and POMDPReweighter are not exported, but can be used to construct the predict and reweight functions for a BasicParticleFilter. The check_particle_belief function can be used as a postprocessing step, and PostprocessChain can be used to chain multiple postprocessing steps together. A function (b, a, o, up.rng) -> ParticleCollection(low_variance_sample(b, 100, up.rng)) or NormalizedESSConditionalResampler can be used as a preprocessing step.","category":"page"},{"location":"basic/#Reference","page":"Basic Particle Filter","title":"Reference","text":"","category":"section"},{"location":"basic/#ParticleFilters.BasicParticleFilter","page":"Basic Particle Filter","title":"ParticleFilters.BasicParticleFilter","text":"BasicParticleFilter(preprocess, predict, reweight, postprocess; [rng], [initialize])\n\nCreate a basic particle filter. See the Basic Particle Filter section of the ParticleFilters.jl documentation for more explanation.\n\nArguments\n\nIn the functions below, b is the belief at the beginning of the update, a is the action, and o is the observation. When present, particles is an AbstractVector of propagated particles, bp is the new belief after the prediciton and reweighting steps, and bb is the belief after the preprocessing step.\n\npreprocess::Function: Function to preprocess the belief before the prediction step. The function should have the signature preprocess(b::AbstractParticleBelief, a, o, rng), and should return a new belief. The returned belief may be the same as b (i.e. modified in place), or a new object.\npredict::Function: Function to propagate the particles forward in time. The function should have the signature predict(b::AbstractParticleBelief, a, o, rng), and should return an AbstractVector of particles.\nreweight::Function: Function to reweight the particles based on the observation. The function should have the signature reweight(b::AbstractParticleBelief, a, particles, o), and should return an AbstractVector of weights.\npostprocess::Function: Function to postprocess the belief after the update. The function should have the signature postprocess(bp::WeightedParticleBelief, a, o, b, bb, rng), and should return a new belief. The returned belief may be the same as bp (i.e. modified in place), or a new object.\n\nKeyword Arguments\n\nrng::AbstractRNG=Random.default_rng(): Random number generator.\ninitialize::Function=(d, rng)->d: Function to initialize the belief by creating a particle belief from a distribution. This can be safely ignored in many applications, but is important in POMDPs.jl. The function should have the signature initialize(d, rng), and should return a new AbstractParticleBelief representing distribution d.\n\n\n\n\n\n","category":"type"},{"location":"bootstrap/#Bootstrap-Filter","page":"Bootstrap Filter","title":"Bootstrap Filter","text":"","category":"section"},{"location":"bootstrap/","page":"Bootstrap Filter","title":"Bootstrap Filter","text":"The BootstrapFilter is the simplest filter provided by the library and should be the starting point for most tasks.","category":"page"},{"location":"bootstrap/#Quick-Start","page":"Bootstrap Filter","title":"Quick Start","text":"","category":"section"},{"location":"bootstrap/","page":"Bootstrap Filter","title":"Bootstrap Filter","text":"With a POMDPs.jl model, setup looks like this:","category":"page"},{"location":"bootstrap/","page":"Bootstrap Filter","title":"Bootstrap Filter","text":"using ParticleFilters, POMDPModels\n\npomdp = TigerPOMDP()\npf = BootstrapFilter(pomdp, 10)","category":"page"},{"location":"bootstrap/","page":"Bootstrap Filter","title":"Bootstrap Filter","text":"Without POMDPs.jl, setup looks like this:","category":"page"},{"location":"bootstrap/","page":"Bootstrap Filter","title":"Bootstrap Filter","text":"using ParticleFilters, Distributions\n\ndynamics(x, u, rng) = x + u + randn(rng)\ny_likelihood(x_previous, u, x, y) = pdf(Normal(), y - x)\npf = BootstrapFilter(dynamics, y_likelihood, 10)","category":"page"},{"location":"bootstrap/","page":"Bootstrap Filter","title":"Bootstrap Filter","text":"Once the filter has been created the update function can be used to perform a particle filter update.","category":"page"},{"location":"bootstrap/","page":"Bootstrap Filter","title":"Bootstrap Filter","text":"b = ParticleCollection([1.0, 2.0, 3.0, 4.0])\nu = 1.0\ny = 3.0\n\nb_new = update(pf, b, u, y)","category":"page"},{"location":"bootstrap/#More-on-the-Bootstrap-Filter","page":"Bootstrap Filter","title":"More on the Bootstrap Filter","text":"","category":"section"},{"location":"bootstrap/","page":"Bootstrap Filter","title":"Bootstrap Filter","text":"The BootstrapFilter is designed to be a sensible default choice for starting with particle filtering. The basic bootstrap filter approach was first described in \"Novel approach to nonlinear / non-Gaussian Bayesian state estimation\" by Gordon, Salmond, and Smith. The version in this package first checks whether the normalized effective sample size of the particle belief is above a threshold (the resample_threshold argument). If it is below the threshold, the belief is resampled using low_variance_sample. The particles are then propagated through the dynamics model and weighted by the likelihood of the observation. ","category":"page"},{"location":"bootstrap/","page":"Bootstrap Filter","title":"Bootstrap Filter","text":"The BootstrapFilter offers a modest level of customization. The most common need for customization is recovering from particle depletion. For this case, use the postprocess keyword argument to specify a function that can be used to check for depletion and recover. See the Handling Particle Depletion section for more information about this task. If more customization is needed, users should use the BasicParticleFilter.","category":"page"},{"location":"bootstrap/#ParticleFilters.BootstrapFilter","page":"Bootstrap Filter","title":"ParticleFilters.BootstrapFilter","text":"BootstrapFilter(pomdp, n; <keyword arguments>)\nBootstrapFilter(dynamics, likelihood, n; <keyword arguments>)\n\nConstruct a standard bootstrap particle filter.\n\nArguments\n\npomdp::POMDP: A POMDP model from POMDPs.jl\ndynamics::Function: A function of the form dynamics(x, u, rng) that returns the next state, xp, given the current state, x, and the action, u. The random number generator, rng, should be used to generate any necessary randomness.\nlikelihood::Function: A function of the form likelihood(x, u, xp, y) that returns the likelihood of observing y given x, u, and xp.\nn::Integer: number of particles\n\nKeyword Arguments\n\nresample_threshold::Float64=0.9: normalized ESS threshold for resampling\npostprocess::Function=(bp, args...)->bp: a function to apply to the belief at the end of each update step. This function should have the form postprocess(bp, b, a, o, rng) and should return a modified version of bp with any postprocessing changes made. See the Particle Depletion section of the ParticleFilters.jl documentation for more information.\nrng::AbstractRNG=Random.default_rng(): random number generator\n\nFor more explanation, see the Bootstrap Filter section of the ParticleFilters.jl package documentation. For a more flexible particle filter structure see BasicParticleFilter.\n\n\n\n\n\n","category":"function"},{"location":"example-feedback/#Example:-Feedback-Control","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"","category":"section"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"In this tutorial, we will give a brief example of how to use a Particle Filter from ParticleFilters.jl for feedback control.","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"using ParticleFilters\nusing Distributions\nusing StaticArrays\nusing LinearAlgebra\nusing Random\nusing Plots","category":"page"},{"location":"example-feedback/#System-Description","page":"Example: Feedback Control","title":"System Description","text":"","category":"section"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"The system is a two-dimensional discrete-time double integrator with gaussian process and observation noise. The state at time k, x_k, is a 4-element vector consisting of the position in two dimensions and the velocity. The dynamics can be represented with the linear difference equation:","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"x_k+1 = f(x_k u_k w_k) = A x_k + B u_k + w_k text","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"where w_k are independent but identically-distributed zero-mean Gaussian random variables with covariance matrix W. A and B are given in the code below.","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"The measurements are noisy observations of the position generated according to ","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"y_k+1 = h(x_k u_k x_k+1 v_k+1) = C x_k+1 + v_k+1 text","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"where C selects only the position of the model, and v_k are independent identically-distributed zero-mean Gaussian random variables with covariance matrix V.","category":"page"},{"location":"example-feedback/#Control-Law-Description","page":"Example: Feedback Control","title":"Control Law Description","text":"","category":"section"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"The control law, will use the mean from the particle filter belief to try to make the state oscillate about the origin, i.e.","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"u = K hatx","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"where hatx is the mean estimate of the state, and","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"K = -1 -1 0 0","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"It should be noted that, since this system is linear with Gaussian noise, a Kalman Filter would be much better-suited for this case, but we use the system here for its simplicity. In general, particle filters can be used with any nonlinear dynamical systems.","category":"page"},{"location":"example-feedback/#Dynamics-model","page":"Example: Feedback Control","title":"Dynamics model","text":"","category":"section"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"We begin by defining the dynamics of the system. For more information about defining a model, see the \"Models\" section of the documentation.","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"const dt = 0.1; # time step\n\nconst A = [1.0 0.0 dt  0.0;\n           0.0 1.0 0.0 dt ;\n           0.0 0.0 1.0 0.0;\n           0.0 0.0 0.0 1.0];\n\nconst B = [0.5*dt^2 0.0     ;\n           0.0      0.5*dt^2;\n           dt       0.0     ;\n           0.0      dt      ];\n\nconst W = 0.3*Matrix(0.01*Diagonal{Float64}(I, 4)); # Process noise covariance\n\nconst V = 0.3*Matrix(Diagonal{Float64}(I, 2)); # Measurement noise covariance\n\nf(x, u, rng) = A*x + B*u + rand(rng, MvNormal(W));","category":"page"},{"location":"example-feedback/#Observation-Model","page":"Example: Feedback Control","title":"Observation Model","text":"","category":"section"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"Next, the observation model is defined. h generates an observation (this is only used in the simulation, not in the particle filter), g returns the relative likelyhood of an observation given the previous state, control, and current state.","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"h(x, rng) = rand(rng, MvNormal(x[1:2], V));\n\ng(x0, u, x, y) = pdf(MvNormal(x[1:2], V), y);","category":"page"},{"location":"example-feedback/#Particle-Filter","page":"Example: Feedback Control","title":"Particle Filter","text":"","category":"section"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"We can combine the dynamics and observation model to create a particle filter.","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"N = 1000; # Number of particles\n\nfilter = BootstrapFilter(f, g, N);","category":"page"},{"location":"example-feedback/#Running-a-Simulation","page":"Example: Feedback Control","title":"Running a Simulation","text":"","category":"section"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"To run a simulation, first an initial belief and initial state need to be created. The initial beleif will consist of particles selected uniformly from -2 2^4.","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"The simulation consists of a loop in which the control is calculated from the mean of the particle. Then the state is updated with the dynamics and a new measurement is generated. Finally, the filter is used to update the belief based on this new measurement.","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"Using the update function in this interactive fashion allows the particle  filter to be used as an estimator/observer for feedback control.","category":"page"},{"location":"example-feedback/","page":"Example: Feedback Control","title":"Example: Feedback Control","text":"rng = Random.default_rng();\nb = ParticleCollection([4.0*rand(4).-2.0 for i in 1:N]); # initial belief\nx = [0.0, 1.0, 1.0, 0.0]; # initial state\n\n@gif for i in 1:100\n    local m = mean(b)\n    u = [-m[1], -m[2]] # Control law - try to orbit the origin\n    global x = f(x, u, rng)\n    y = h(x, rng)\n    global b = update(filter, b, u, y)\n\n    plt = scatter([p[1] for p in particles(b)], [p[2] for p in particles(b)], color=:black, markersize=2, alpha=sqrt.(weights(b)./weight_sum(b)), label=\"\")\n    scatter!(plt, [x[1]], [x[2]], color=:blue, xlim=(-5,5), ylim=(-5,5), label=\"\")\nend fps=5","category":"page"},{"location":"sampling/#Sampling","page":"Sampling","title":"Sampling","text":"","category":"section"},{"location":"sampling/","page":"Sampling","title":"Sampling","text":"One of the easiest performance mistakes to make when first implementing particle filters is inefficient resampling. Using off-the-shelf functions that sequentially draw samples from a categorical distribution can easily result in O(n^2) or even O(n^3) resampling. Fortunately O(n) or O(n)log(n) algorithms exist for this task.","category":"page"},{"location":"sampling/","page":"Sampling","title":"Sampling","text":"This package has two features to improve sampling.","category":"page"},{"location":"sampling/","page":"Sampling","title":"Sampling","text":"First, by default, calling rand on a WeightedParticleBelief uses an alias table to sample according to the weights. This is an O(n) algorithm that is particularly efficient when the number of samples is large. The Alias table is constructed in O(nlog(n)) time, and taking uncorrelated samples using the table is O(1).","category":"page"},{"location":"sampling/","page":"Sampling","title":"Sampling","text":"Second, the low_variance_sample function implements the algorithm described on page 110 of Probabilistic Robotics by Thrun, Burgard, and Fox. This O(n) algorithm produces a low-variance set of samples distributed throughout the collection. This method is used by default in the BootstrapFilter.","category":"page"},{"location":"sampling/#ParticleFilters.low_variance_sample","page":"Sampling","title":"ParticleFilters.low_variance_sample","text":"low_variance_sample(b::AbstractParticleBelief, n[, rng])\n\nSample an AbstractVector of n particles according to their weights using the \"low variance\" sampling algorithm on page 110 of Probabilistic Robotics by Thrun Burgard and Fox. O(n) runtime, correlated samples, but produces a useful low-variance set.\n\n\n\n\n\n","category":"function"},{"location":"example-filtering/#Example:-Filtering-Preexisting-Data","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"","category":"section"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"In some cases, there is no need to perform control based on the particle belief and instead the goal is to filter a previously-generated sequence of measurements to remove noise or reconstruct hidden state variables. This tutorial will illustrate use of the runfilter function for that purpose.","category":"page"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"First, we import the packages we will use. ","category":"page"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"using Distributions\nusing Random\nusing DelimitedFiles\nusing ParticleFilters\nusing VegaLite","category":"page"},{"location":"example-filtering/#Model","page":"Example: Filtering Preexisting Data","title":"Model","text":"","category":"section"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"We will use Euler-integrated Van Der Pol Oscillator Equations with noise added as the dynamics (f), and measurements of the position with gaussian noise added (the pdf is encoded in g).","category":"page"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"This model is implemented below. For more information on defining models for particle filters, see the documentation.","category":"page"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"const dt = 0.2\nconst mu = 0.8\nconst sigma = 1.0\n\nfunction f(x, u, rng)\n    xdot = [x[2], mu * (1 - x[1]^2) * x[2] - x[1] + u + 0.1 * randn(rng)]\n    return x + dt * xdot\nend\n\ng(x1, u, x2, y) = pdf(Normal(sigma), y - x2[1])\nnothing # hide","category":"page"},{"location":"example-filtering/#Data","page":"Example: Filtering Preexisting Data","title":"Data","text":"","category":"section"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"Suppose that the data we would like to filter are contained in text files. u.txt contains the control inputs, and y.txt contains the measurements. The code that generated this data can be found in the appendix below.","category":"page"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"ys = vec(readdlm(\"y.txt\"));\nus = vec(readdlm(\"u.txt\"));\nnothing # hide","category":"page"},{"location":"example-filtering/#Filtering","page":"Example: Filtering Preexisting Data","title":"Filtering","text":"","category":"section"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"We can use an SIR particle filter to get a better estimate of the state. Note that we start with an initial belief consisting of particles with zero velocity and position uniformly distributed in -5 5.","category":"page"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"n = 10_000\n\nfil = BootstrapFilter(f, g, n)\n\n# construct initial belief\nb0 = ParticleCollection([[10.0 * (rand() - 0.5), 0.0] for i in 1:n])\n\nbs = runfilter(fil, b0, us, ys)","category":"page"},{"location":"example-filtering/#Plotting-the-Results","page":"Example: Filtering Preexisting Data","title":"Plotting the Results","text":"","category":"section"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"We can now plot the observations, the smoothed estimate of the position (the mean of the belief at every time step), and the true state. Note that the estimated position is much closer to the true position than the noisy measurements.","category":"page"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"xmat = readdlm(\"x.txt\");\n\nplot_data = [(; t, x1=x[1], x2=x[2], y, b_mean=mean(b)[1]) for (t, (x, y, b)) in enumerate(zip(eachslice(xmat; dims=1), ys, bs))]\n\nplot_data |> @vlplot(x = :t, width = 700) +\n             @vlplot(:line, y = :x1, color = {datum = \"True State\"}) +\n             @vlplot(:point, y = :y, color = {datum = \"Observation\"}) +\n             @vlplot(:line, y = :b_mean, color = {datum = \"Mean Belief\"})","category":"page"},{"location":"example-filtering/#Appendix","page":"Example: Filtering Preexisting Data","title":"Appendix","text":"","category":"section"},{"location":"example-filtering/#Code-for-Generating-Data","page":"Example: Filtering Preexisting Data","title":"Code for Generating Data","text":"","category":"section"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"The following code can be used to generate the data in the text files:","category":"page"},{"location":"example-filtering/","page":"Example: Filtering Preexisting Data","title":"Example: Filtering Preexisting Data","text":"rng = MersenneTwister(1)\n\nk = 100\nh(x, rng) = x[1] + sigma*randn(rng)\n\nx = [3.0, 0.0]\nxs = Array{typeof(x)}(undef, k)\nus = zeros(k)\nys = zeros(k)\nfor t in 1:k\n    x = f(x, us[t], rng)\n    ys[t] = h(x, rng)\n    xs[t] = x\nend\n\nusing DelimitedFiles\nwritedlm(\"x.txt\", xs)\nwritedlm(\"y.txt\", ys)\nwritedlm(\"u.txt\", us)","category":"page"},{"location":"example-pomdps/#Example:-Use-with-POMDPs.jl","page":"Example: Use with POMDPs.jl","title":"Example: Use with POMDPs.jl","text":"","category":"section"},{"location":"example-pomdps/","page":"Example: Use with POMDPs.jl","title":"Example: Use with POMDPs.jl","text":"The particle filters in ParticleFilters.jl can be used out of the box as updaters for POMDPs.jl. This tutorial will briefly demonstrate usage with the LightDark problem from POMDPModels.jl.","category":"page"},{"location":"example-pomdps/","page":"Example: Use with POMDPs.jl","title":"Example: Use with POMDPs.jl","text":"using ParticleFilters\nusing POMDPs\nusing POMDPModels\nusing POMDPTools\nusing Random\nusing Plots","category":"page"},{"location":"example-pomdps/#Running-a-Simulation","page":"Example: Use with POMDPs.jl","title":"Running a Simulation","text":"","category":"section"},{"location":"example-pomdps/","page":"Example: Use with POMDPs.jl","title":"Example: Use with POMDPs.jl","text":"The following code creates the pomdp model and the associated particle filter and runs a simulation producing a history.","category":"page"},{"location":"example-pomdps/","page":"Example: Use with POMDPs.jl","title":"Example: Use with POMDPs.jl","text":"rng = MersenneTwister(1)\npomdp = LightDark1D();\nN = 5000;\nup = BootstrapFilter(pomdp, N, rng=rng);\npolicy = FunctionPolicy(b->1);\nb0 = POMDPModels.LDNormalStateDist(-15.0, 5.0);\nhr = HistoryRecorder(rng = rng, max_steps=40);\n\nhistory = simulate(hr, pomdp, policy, up, b0);\nnothing # hide","category":"page"},{"location":"example-pomdps/#Visualization","page":"Example: Use with POMDPs.jl","title":"Visualization","text":"","category":"section"},{"location":"example-pomdps/","page":"Example: Use with POMDPs.jl","title":"Example: Use with POMDPs.jl","text":"We can then plot the particle distribution at each step using Plots.jl.","category":"page"},{"location":"example-pomdps/","page":"Example: Use with POMDPs.jl","title":"Example: Use with POMDPs.jl","text":"Note that as the belief passes through the light region (centered at y=5), the belief concentrates on a single state.","category":"page"},{"location":"example-pomdps/","page":"Example: Use with POMDPs.jl","title":"Example: Use with POMDPs.jl","text":"@gif for b in belief_hist(history)\n    local ys = [s.y for s in particles(b)]\n    local nbins = max(1, round(Int, (maximum(ys)-minimum(ys))*2))\n    histogram(\n        ys,\n        xlim = (-20,20),\n        ylim = (0,1000),\n        nbins = nbins,\n        label = \"\",\n        title = \"Particle Histogram\"\n    )                    \nend fps=5","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ParticleFilters.jl provides a basic particle filter, along with some useful tools for constructing more complex particle filters. In particular it provides both weighted and unweighted particle belief types that implement the POMDPs.jl distribution interface including sampling and automatic caching of probability masses. Additionally, an important requirement for a particle filter is efficient resampling. This package provides O(n) sampling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dynamics and measurement models for the filters can be specified with a few functions or a POMDP. The simplest Bootstrap Particle filter can be constructed with BootstrapFilter. BasicParticleFilter provides a more flexible structure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are tutorials for three ways to use the particle filters:","category":"page"},{"location":"","page":"Home","title":"Home","text":"As an estimator for feedback control,\nto filter time-series measurements, and\nas an updater for POMDPs.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For documentation on all aspects of the package, see the contents below.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = Main.page_order","category":"page"}]
}
